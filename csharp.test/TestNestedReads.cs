using System.IO;
using NUnit.Framework;

namespace ParquetSharp.Test
{
    [TestFixture]
    public class TestNestedReads
    {

        /// <summary>
        /// Currently ParquetSharp cannot write nested structures.
        /// We are using a Parquet file found in TestFiles/nested.parquet, generated by TestFiles/generate_parquet.py to test the ParquetSharp reader.
        /// </summary>
        [Test]
        public void CanReadNestedStructure()
        {
            var directory = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
            var path = Path.Combine(directory!, "TestFiles/nested.parquet");

            using var fileReader = new ParquetFileReader(path);
            var rowGroupReader = fileReader.RowGroup(0);

            // first_level_long
            var column0Reader = rowGroupReader.Column(0).LogicalReader<long?>();
            var column0Actual = column0Reader.ReadAll(2);
            var column0Expected = new[] {1, 2};
            Assert.AreEqual(column0Expected, column0Actual);

            // first_level_nullable_string
            var column1Reader = rowGroupReader.Column(1).LogicalReader<string?>();
            var column1Actual = column1Reader.ReadAll(2);
            var column1Expected = new[] {null, "Not Null String"};
            Assert.AreEqual(column1Expected, column1Actual);

            // nullable_struct.nullable_struct_string
            var column2Reader = rowGroupReader.Column(2).LogicalReader<Nested<string>?>();
            var column2Actual = column2Reader.ReadAll(2);
            var column2Expected = new Nested<string>?[] {new Nested<string>("Nullable Struct String"), null};
            Assert.AreEqual(column2Expected, column2Actual);

            // struct.struct_string
            var column3Reader = rowGroupReader.Column(3).LogicalReader<Nested<string>?>();
            var column3Actual = column3Reader.ReadAll(2);
            var column3Expected = new Nested<string>?[] {new Nested<string>("First Struct String"), new Nested<string>("Second Struct String")};
            Assert.AreEqual(column3Expected, column3Actual);

            // struct_array.array_in_struct_array
            var column4Reader = rowGroupReader.Column(4).LogicalReader<Nested<long?[]>?[]>();
            var column4Actual = column4Reader.ReadAll(2);
            var column4Expected = new Nested<long?[]>?[][] {
                new Nested<long?[]>?[] {
                    new Nested<long?[]>(new long?[] {111, 112, 113}),
                    new Nested<long?[]>(new long?[] {121, 122, 123})
                },
                new Nested<long?[]>?[] {
                    new Nested<long?[]>(new long?[] {211, 212, 213})
                }
            };
            AssertEqual(column4Expected, column4Actual);

            // struct_array.string_in_struct_array
            var column5Reader = rowGroupReader.Column(5).LogicalReader<Nested<string>?[]>();
            var column5Actual = column5Reader.ReadAll(2);
            var column5Expected = new Nested<string>?[][] {
                new Nested<string>?[] { new Nested<string>("First String"), new Nested<string>("Second String") },
                new Nested<string>?[] { new Nested<string>("Third String") }
            };
            Assert.AreEqual(column5Expected, column5Actual);
        }

        void AssertEqual<T>(T[]? expected, T[]? actual)
        {
            Assert.AreEqual(expected == null, actual == null);
            if (actual != null && expected != null)
            {
                Assert.AreEqual(expected.Length, actual.Length);
                for (var i=0; i<expected.Length; i++)
                {
                    AssertEqual(expected[i] as dynamic, actual[i] as dynamic);
                }
            }
        }

        void AssertEqual<T>(Nested<T> expected, Nested<T> actual)
        {
            AssertEqual(expected.Value as dynamic, actual.Value as dynamic);
        }

        void AssertEqual(long expected, long actual)
        {
            Assert.AreEqual(expected, actual);
        }

        void AssertEqual(object? expected, object? actual)
        {
            Assert.AreEqual(expected, actual);
        }
    }
}
